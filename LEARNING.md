# Crate 
crate = หน่วยของโค้ดใน Rust
- ถ้าเป็น binary crate 👉 คือโปรเจกต์สามารถ build ออกมาเป็นไฟล์ executable ได้ เช่น main.rs ที่มี fn main()
- ถ้าเป็น library crate 👉 คือชุดของโค้ดหรือฟังก์ชั่น ที่เขียนมาให้โปรเจกต์อื่นเรียกใช้ จะรันตรงๆไม่ได้ เช่นในโปรเจกต์ guessing_game ที่เราจะใช้การสุ่มเลขผลลัพธ์คำตอบ ก็จะใช้เป็น library crate โค้ด/ฟังก์ชั่น crate rand สุ่มเลขที่คนอื่นเขียนไว้

✨ซึ่งวิธีเอา crate rand มาใช้เราก็ต้องเพิ่มใน depedency ที่มี cargo ช่วยจัดการ
--

# Cargo
cargo = ตัวจัดการแพ็คเกจของ Rust
มีหน้าที่ต่างๆ เช่น
1. จัดการ dependency (crate อื่นๆ ที่โปรเจกต์เราใช้)
2. สั่ง build ให้
3. สั่ง run/ test / publish ได้

## การเพิ่ม dependency
เวลาที่เราจะใช้ crate ภายนอก เช่น rand เราก็ต้องบอก cargo ก่อน โดยแก้ที่ไฟล์ Cargo.toml (อันนี้ตอนเราสร้างโปรเจกต์ด้วย cargo new นางจะจัดการสร้างให้เอง เลิศๆ)

ตรง dependencies เราเพิ่ม rand เข้าไป ถ้าเอาตามเอกสารสอน Rust Book (ดู ณ 2025/08/31) จะได้ประมาณนี้

[dependencies]
rand = "0.8.5"

🔥แต่ตอนที่เราใส่มันขึ้นกากบาทและตามด้วยเวอร์ชั่นล่าสุดเป็น 0.9.2 (อันนี้ของเราขึ้นแบบนี้ คนอื่นขึ้นแบบไหนไม่รู้) แต่เราไม่เปลี่ยนเพราะเราจะทำตามเอกสารสอนเลย อีกอย่างคือเขาบอกในเอกสารว่า 
"Any version 0.9.0 or greater is not guaranteed to have the same API as what the following examples use." 
ประมาณว่า เวอร์ชัน 0.9.0 หรือสูงกว่าไม่ได้รับประกันว่าจะมี API เดียวกันกับที่ตัวอย่างที่โปรเจคใช้ไหม

# Cargo.lock
หลังจากที่เราเพิ่ม rand = "0.8.5" ใน [dependencies] แล้วเราก็ใช้คำสั่ง cargo build ที่ Terminal จากนั้น → cargo จะเลือกเวอร์ขั่น dependency ที่ตรงตามเงื่อนไขที่เราระบุใน Cargo.toml
🔹แล้ว cargo ก็จะเขียนรายละเอียดเวอร์ชันจริงๆ ที่ใช้ลงใน Cargo.lock
🔹ซึ่งต่อไปทุกครั้งที่ build Cargo จะดูจาก Cargo.lock ทำให้ได้ dependency เวอร์ชั่นเดิมเป๊ะ 
🔹ทำให้ Build reproducible คือ build ได้เหมือนเดิมทุกครั้ง ไม่ว่าจะ build ที่เครื่องเรา หรือที่เครื่องเพื่อน
🔹แต่เวอร์ชัน dependency จะไม่เปลี่ยนจนกว่าเราจะสั่งอัปเดตเอง เช่น cargo update


## สรุป Cargo.toml และ Cargo.lock
- Cargo.toml = เราเขียนเงื่อนไขเวอร์ชันของ dependency
- Cargo.lock = Cargo จะ lock เวอร์ชันจริงๆ ที่ถูกใช้ในตอน build
- เวลา push code → ควร push Cargo.lock ไปด้วย (ถ้าเป็น binary crate เช่นโปรเจกต์ guessing_game)
- ยกเว้นถ้าเป็น library crate → บางครั้งจะไม่ commit Cargo.lock เพราะอยากให้ผู้ใช้ library นั้นได้ dependency ใหม่ล่าสุดที่เข้ากันได้ในโปรเจกต์นั้นๆ

▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎

# use std::cmp::Ordering;
คือการ นำเข้า (import) enum ที่ชื่อว่า Ordering จาก standard library ของ Rust
👉Ordering เป็น enum ที่มีค่าที่เป็นไปได้ 3 แบบ คือ
Less → น้อยกว่า
Greater → มากกว่า
Equal → เท่ากัน

👉cmp
cmp เป็น method สำหรับ เปรียบเทียบค่า
ตัวอย่าง guess.cmp(&secret_number)
🔹จะเปรียบเทียบค่า guess กับ secret_number
🔹แล้ว return ค่าออกมาเป็น Ordering (Less, Greater หรือ Equal)

## match expression
match ใช้ตรวจสอบว่า ค่าที่ได้เป็นแบบไหน

โครงสร้าง match จะมี arms (แขน) ซึ่งแต่ละ arm กำหนด pattern กับโค้ดที่จะทำงาน

เช่น

match guess.cmp(&secret_number) {
    Ordering::Less => println!("Too small!"),
    Ordering::Greater => println!("Too big!"),
    Ordering::Equal => println!("You win!"),
}


👉การทำงานคือ
- นำค่าที่ได้จาก cmp มาเช็ค
- ไล่เช็คแต่ละ arm ทีละอัน
- เจออันที่ตรง → รันโค้ดใน arm นั้น
- หยุดเลย ไม่ไปเช็ค arm ต่อไป

👉ตัวอย่าง

- ถ้า guess = 50 และ secret_number = 38
- guess.cmp(&secret_number) จะ return Ordering::Greater
- match จะเช็คว่า
    ตรงกับ Ordering::Less ไหม → ไม่ตรง
    ตรงกับ Ordering::Greater ไหม → ตรง → รัน println!("Too big!");
    เสร็จสิ้น ไม่ต้องเช็ค Equal ต่อ

▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎

# การแปลงค่า String → ตัวเลข
- ต้องแปลงเพราะตอนแรกเรารับค่าผู้ใช้มา io::stdin() คืนค่าเป็น String เสมอ
- ตอนเปรียบเทียบค่าตรง match ถ้าเราไม่แปลงค่าที่รับมาเป็นตัวเลข จะ error >> Rust จะฟ้อง mismatched types (string vs number)
- เพราะ string (guess) เปรียบเทียบกับค่าเลข(secret_number)ไม่ได้

let guess: u32 = guess.trim().parse().expect("Please type a number!");

👉เวลาผู้ใช้พิมพ์ตัวเลขแล้วกด Enter เช่น 5 โปรแกรมจริงๆ จะได้ "5\n" (เพราะ Enter แถม newline มาด้วย)
- ใช้ trim() → "5" (ตัดช่องว่างและ newline ออก)
- ใช้ parse() → 5 (พยายามแปลง string เป็น เลข)

👉 บอกชนิดข้อมูล ตรง let guess: u32
- บอก Rust ว่าเราจะใช้ เลขจำนวนเต็มบวก 32 บิต
- Rust ก็เลย infer (เดา) ต่อว่า secret_number ที่เราเปรียบเทียบด้วย ต้องเป็น u32 เช่นกัน

👉expect
- parse() พยายามแปลง String → ตัวเลข
- ถ้า String เป็น "123" → สำเร็จ (Ok(123))
- ถ้า String เป็น "A👍%" → แปลงไม่ได้ (Err)
- เพราะงั้น parse() คืนค่า Result กลับมา
- expect("Please type a number!") คือการบอกว่า
    ถ้า สำเร็จ → ดึงค่าออกมาใช้ได้เลย
    ถ้า ล้มเหลว → โปรแกรมหยุด พร้อมโชว์ข้อความนี้ "Please type a number!"

▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎

# Allowing Multiple Guesses with Looping
คือให้ผู้ใช้กรอกเลขเดามาเรื่อยๆได้จนกว่าจะถูก เราจะใช้ Loop 

## ทำไมต้องใช้ loop
- loop { ... } คือการวนลูป ไม่มีวันจบเอง
- พอเราเอาโค้ดรับค่า + ตรวจสอบค่ามาใส่ใน loop → ผู้เล่นก็จะได้ลองเดาหลายครั้ง ไม่ใช่แค่ครั้งเดียว
- เช่น:
loop {
    println!("Please input your guess.");
    // รับ input และเปรียบเทียบ
}

💥ปัญหาที่เกิดขึ้นจาก loop { ... }
ตอนนี้เกมจะ วนตลอดไป ไม่มีจบ

วิธีออกจากเกมที่มีตอนนี้
>> กด ctrl-c เพื่อบังคับหยุด (ไม่สวยงาม)
>> หรือใส่ input ที่ไม่ใช่ตัวเลข เช่น "quit", "abc" → โปรแกรม crash (เพราะ parse แปลงไม่ได้ → Err)
    แต่การให้ crash ถือว่าเป็น การออกแบบที่ไม่ดี เพราะมันไม่ได้บอกว่า "นี่คือการจบเกมที่ตั้งใจ" แต่เป็นการพังของโปรแกรม

อย่างในเกมที่เราเขียน
ต่อให้ผู้ใช้เดาถูกละขึ้นข้อความ "You win!" โปรแกรมก็จะยังไม่หยุดให้ผู้ใช้กรอกเลขเดาต่อ เพราะเราไม่ได้ใส่เงื่อนไขอะไร
👉สิ่งที่เราต้องการคือ ถ้าเดาไม่ถูกก็วนเรื่อยๆ ให้ผู้ใช้กรอกเลขเดามาจนกว่าจะตรงกันกับคำตอบ Equal ขึ้นข้อความ You win! แล้วก็จบ
🔹เพราะงั้นเราต้องเพิ่มเติมเงื่อนไขเข้าไปในส่วนของบรรทัด Ordering::Equal => println!("You win!") ใหม่เป็น

match guess.cmp(&secret_number) {
    Ordering::Less => println!("Too small!"),
    Ordering::Greater => println!("Too big!"),
    Ordering::Equal => {
        println!("You win!");
        break; // หยุดลูป จบเกม
    }
}

▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎

# การแปลงค่า ก่อนหน้านี้ (ใช้ .expect()) ปรับใหม่ (ใช้ match)
- ก่อนหน้านี้ → ถ้า input ไม่ใช่ตัวเลข = เกม crash ❌
- ตอนนี้ → ถ้า input ไม่ใช่ตัวเลข = แค่ข้ามรอบนั้น วนถามใหม่ 🔄

อันนี้คือแบบใหม่ใช้ match
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};

👉อธิบาย
- parse() คืนค่าเป็น Result (มี 2 แบบ)
    Ok(num) → แปลงสำเร็จ ได้เลขออกมา
    Err(e) → แปลงไม่สำเร็จ มี error กลับมา

- เราใช้ match แยกกรณี
    Ok(num) → ดึงตัวเลข num มาใช้ → ตัวเลขนี้จะไปเก็บใน guess (ชนิด u32)
    Err(_) → ไม่สนว่ามี error อะไร แค่สั่ง continue → วนลูปใหม่ทันที ให้ user เดาอีกรอบ

❓ทำไมต้องใช้ _
_ เป็น wildcard = ไม่สนว่าข้างใน Err มีข้อมูล error อะไร
เขียนว่า Err(_) หมายถึง จับทุก error ที่เกิดขึ้น 

🔥ผลลัพธ์การทำงาน
- ถ้า user พิมพ์ "45" → parse สำเร็จ → guess = 45 → เกมทำงานต่อ
- ถ้า user พิมพ์ "quit" หรือ "hello" → parse ไม่สำเร็จ → เข้ากรณี Err(_) → continue → เกมไม่ crash แต่วนไปถามใหม่

▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎▪︎

# 🌟เพิ่มเติม
โค้ด println!("(The secret number is: {secret_number})"); 
- เขียนเพื่อ debug 
- แบบว่าโค้ดเรายังไม่เสร็จสมบูรณ์ เราก็อยากตรวจสอบการทำงานของโค้ด
- ตรวจสอบว่าเลขสุ่มทำงานจริงไหม 
- การเปิดดูเลข Secret ก่อน จะช่วยประหยัดเวลา เพราะเราจะได้กดเลขได้สูง, ต่ำ, เท่ากับดูการแสดงผลได้เลย
- ถ้าโปรแกรมเราโอเคแล้วก็ลบส่วนนี้ออกภายหลัง เพื่อให้เป็นเกมจริง ไม่เฉลยคำตอบให้ผู้เล่นน้าาา😆